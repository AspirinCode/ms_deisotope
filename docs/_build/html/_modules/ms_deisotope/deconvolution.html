
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ms_deisotope.deconvolution &#8212; ms_deisotope  documentation</title>
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><img class="rightlogo" src="../../_static/logo.svg" alt="Logo"/><h1 class="heading"><a href="../../index.html">
          <span>ms_deisotope  documentation</span></a></h1>
        <h2 class="heading"><span>ms_deisotope.deconvolution</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for ms_deisotope.deconvolution</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">ms_peak_picker</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">FittedPeak</span><span class="p">,</span> <span class="n">PeakSet</span><span class="p">,</span> <span class="n">PeakIndex</span><span class="p">,</span> <span class="n">simple_peak</span><span class="p">,</span> <span class="n">is_peak</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.averagine</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">AveragineCache</span><span class="p">,</span> <span class="n">peptide</span><span class="p">,</span> <span class="n">glycopeptide</span><span class="p">,</span> <span class="n">glycan</span><span class="p">,</span> <span class="n">neutral_mass</span><span class="p">,</span> <span class="n">isotopic_variants</span><span class="p">,</span>
    <span class="n">isotopic_shift</span><span class="p">,</span> <span class="n">PROTON</span><span class="p">,</span> <span class="n">TheoreticalIsotopicPattern</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.peak_set</span> <span class="k">import</span> <span class="n">DeconvolutedPeak</span><span class="p">,</span> <span class="n">DeconvolutedPeakSolution</span><span class="p">,</span> <span class="n">DeconvolutedPeakSet</span><span class="p">,</span> <span class="n">Envelope</span>
<span class="kn">from</span> <span class="nn">.scoring</span> <span class="k">import</span> <span class="n">IsotopicFitRecord</span><span class="p">,</span> <span class="n">penalized_msdeconv</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="n">Base</span><span class="p">,</span> <span class="n">TrivialTargetedDeconvolutionResult</span><span class="p">,</span> <span class="n">DeconvolutionProcessResult</span>
<span class="kn">from</span> <span class="nn">.envelope_statistics</span> <span class="k">import</span> <span class="n">a_to_a2_ratio</span><span class="p">,</span> <span class="n">average_mz</span><span class="p">,</span> <span class="n">most_abundant_mz</span>
<span class="kn">from</span> <span class="nn">.peak_dependency_network</span> <span class="k">import</span> <span class="n">PeakDependenceGraph</span><span class="p">,</span> <span class="n">NetworkedTargetedDeconvolutionResult</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
    <span class="n">MAX_ITERATION</span><span class="p">,</span>
    <span class="n">ERROR_TOLERANCE</span><span class="p">,</span>
    <span class="n">IGNORE_BELOW</span><span class="p">,</span>
    <span class="n">CONVERGENCE</span><span class="p">,</span>
    <span class="n">SCALE_METHOD</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;deconvolution&quot;</span><span class="p">)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span>
<span class="n">debug</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">error</span>


<span class="k">def</span> <span class="nf">prepare_peaklist</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">PeakIndex</span><span class="p">):</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">PeakSet</span><span class="p">(</span><span class="n">peaks</span><span class="o">.</span><span class="n">peaks</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PeakSet</span><span class="p">([])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FittedPeak</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_peak</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">simple_peak</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">intensity</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">simple_peak</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.01</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot convert peaks into a PeakSet&quot;</span><span class="p">)</span>

        <span class="n">peaks</span> <span class="o">=</span> <span class="n">PeakSet</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">peaks</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">peaks</span>


<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mf">1.</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="n">n</span>


<span class="k">def</span> <span class="nf">has_previous_peak_at_charge</span><span class="p">(</span><span class="n">peak_collection</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the `step`th *preceding* peak from `peak` in a isotopic pattern at</span>
<span class="sd">    charge state `charge`, or return `None` if it is missing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peak_collection : DeconvoluterBase</span>
<span class="sd">        Peak collection to look up peaks in. Calls :meth:`has_peak`</span>
<span class="sd">    peak : ms_peak_picker.FittedPeak</span>
<span class="sd">        The peak to use as a point of reference</span>
<span class="sd">    charge : int, optional</span>
<span class="sd">        The charge state to interpolate from. Defaults to 2.</span>
<span class="sd">    step : int, optional</span>
<span class="sd">        The number of peaks along the isotopic pattern to search.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FittedPeak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">-</span> <span class="n">isotopic_shift</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
    <span class="k">return</span> <span class="n">peak_collection</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">has_successor_peak_at_charge</span><span class="p">(</span><span class="n">peak_collection</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the `step`th *succeeding* peak from `peak` in a isotopic pattern at</span>
<span class="sd">    charge state `charge`, or return `None` if it is missing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peak_collection : DeconvoluterBase</span>
<span class="sd">        Peak collection to look up peaks in. Calls :meth:`has_peak`</span>
<span class="sd">    peak : ms_peak_picker.FittedPeak</span>
<span class="sd">        The peak to use as a point of reference</span>
<span class="sd">    charge : int, optional</span>
<span class="sd">        The charge state to interpolate from. Defaults to 2.</span>
<span class="sd">    step : int, optional</span>
<span class="sd">        The number of peaks along the isotopic pattern to search.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FittedPeak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nxt</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">+</span> <span class="n">isotopic_shift</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
    <span class="k">return</span> <span class="n">peak_collection</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">nxt</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">first_peak</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the first non-placeholder peak in a list of peaks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : Iterable of FittedPeak</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FittedPeak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">peak</span>


<span class="k">def</span> <span class="nf">drop_placeholders</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Removes all placeholder peaks from an iterable of peaks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : Iterable of FittedPeak</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span> <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">count_placeholders</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Counts the number of placeholder peaks in an iterable</span>
<span class="sd">    of FittedPeaks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : Iterable of FittedPeak</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Number of placeholder peaks</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>


<span class="k">def</span> <span class="nf">drop_placeholders_parallel</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">otherpeaks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given two parallel iterables of Peak objects, `peaks` and `otherpeaks`,</span>
<span class="sd">    for each position that is not a placeholder in `peaks`, include that Peak object</span>
<span class="sd">    and its counterpart in `otherpeaks` in a pair of output lists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : Iterable of FittedPeak</span>
<span class="sd">        Peak collection to filter against</span>
<span class="sd">    otherpeaks : Iterable</span>
<span class="sd">        Collection of objects (Peak-like) to include based upon</span>
<span class="sd">        contents of `peaks`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        Filtered form of `peaks`</span>
<span class="sd">    list</span>
<span class="sd">        Filtered form of `otherpeaks`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_otherpeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)):</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="n">new_otherpeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">otherpeaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">new_peaks</span><span class="p">,</span> <span class="n">new_otherpeaks</span>


<span class="k">def</span> <span class="nf">from_fitted_peak</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a :class:`~.FittedPeak` into a :class:`~.DeconvolutedPeak`</span>
<span class="sd">    at the specified charge state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peak : :class:`~.FittedPeak`</span>
<span class="sd">        The fitted peak to use as the template</span>
<span class="sd">    charge : int, optional</span>
<span class="sd">        The charge state to use, defaults to 1+</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~.DeconvolutedPeak`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mass</span> <span class="o">=</span> <span class="n">neutral_mass</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">)</span>
    <span class="n">dpeak</span> <span class="o">=</span> <span class="n">DeconvolutedPeak</span><span class="p">(</span>
        <span class="n">mass</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">signal_to_noise</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">full_width_at_half_max</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Envelope</span><span class="p">([(</span><span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span><span class="p">)]),</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">peak</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpeak</span>


<span class="k">class</span> <span class="nc">DeconvoluterBase</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for all Deconvoluter types. Provides basic configuration for common operations,</span>
<span class="sd">    regardless of implementation. Because these methods form the backbone of all deconvolution algorithms,</span>
<span class="sd">    this class has a C-extension implementation as well.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    peaklist : ms_peak_picker.PeakSet</span>
<span class="sd">        The centroided mass spectrum to deconvolute</span>
<span class="sd">    scorer : IsotopicFitterBase</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    merge_isobaric_peaks : bool</span>
<span class="sd">        If multiple passes produce peaks with identical mass values,</span>
<span class="sd">        should those peaks be summed</span>
<span class="sd">    minimum_intensity : float</span>
<span class="sd">        Experimental peaks whose intensity is below this level will be ignored</span>
<span class="sd">        by peak querying methods</span>
<span class="sd">    scale_method : str</span>
<span class="sd">        The name of the method to use to scale theoretical isotopic pattern intensities</span>
<span class="sd">        to match the experimental isotopic pattern</span>
<span class="sd">    use_subtraction : bool</span>
<span class="sd">        Whether or not to apply a subtraction procedure to experimental peaks after they</span>
<span class="sd">        have been fitted. This is only necessary if the same signal may be examined multiple</span>
<span class="sd">        times as in a multi-pass method or when peak dependence is not considered</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Produce extra logging information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_subtraction</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">scale_method</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span>
    <span class="n">merge_isobaric_peaks</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">minimum_intensity</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">minimum_intensity</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span> <span class="o">=</span> <span class="n">use_subtraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_method</span> <span class="o">=</span> <span class="n">scale_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_isobaric_peaks</span> <span class="o">=</span> <span class="n">merge_isobaric_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_intensity</span> <span class="o">=</span> <span class="n">minimum_intensity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">has_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query :attr:`peaklist` for a peak at `mz` within `error_tolerance` ppm. If a peak</span>
<span class="sd">        is not found, this method returns a placeholder peak.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mz : float</span>
<span class="sd">            The m/z to search for a peak at</span>
<span class="sd">        error_tolerance : float</span>
<span class="sd">            The parts-per-million error tolerance to search with</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FittedPeak</span>
<span class="sd">            A peak from :attr:`peaklist` if present, else a placeholder peak.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_intensity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FittedPeak</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">peak</span>

    <span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a slice from :attr:`peaklist` using it&#39;s :meth:`between` method. Caches</span>
<span class="sd">        repeated queries in :attr:`_scan_cache`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m1 : float</span>
<span class="sd">            The low m/z to slice from</span>
<span class="sd">        m2 : float</span>
<span class="sd">            The high m/z to slice from</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PeakSet</span>
<span class="sd">            The subset of peaks from :attr:`peaklist` between `m1` and `m2`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
            <span class="k">return</span> <span class="n">region</span>

    <span class="k">def</span> <span class="nf">match_theoretical_isotopic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theoretical_distribution</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a list of theoretical peaks, find their counterparts in :attr:`peaklist` within `error_tolerance`</span>
<span class="sd">        ppm error. If no experimental peak is found, a placeholder will be used in its stead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theoretical_distribution : list of :class:`~.TheoreticalPeak`</span>
<span class="sd">            The theoretical isotopic pattern to match</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            Parts-per-million error tolerance to permit in searching for matches</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of :class:`~.FittedPeak`</span>
<span class="sd">            The list of matched peaks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">experimental_distribution</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">theoretical_distribution</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">experimental_distribution</span>

    <span class="k">def</span> <span class="nf">scale_theoretical_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theoretical_distribution</span><span class="p">,</span> <span class="n">experimental_distribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale up a theoretical isotopic pattern such that its total intensity matches the experimental</span>
<span class="sd">        isotopic pattern. This mutates `theoretical_distribution`.</span>

<span class="sd">        This assumes that the sum of intensities in `theoretical_distribution` is 1.0. This method is also</span>
<span class="sd">        not particularly kind to isotopic patterns where there are missing peaks.</span>

<span class="sd">        The scaling algorithm used is controlled by :attr:`scale_method`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theoretical_distribution : list of :class:`~.TheoreticalPeak`</span>
<span class="sd">            The theoretical isotopic pattern to scale up</span>
<span class="sd">        experimental_distribution : list of :class:`~.FittedPeak`</span>
<span class="sd">            The experimental isotopic pattern to use as a reference</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of :class:`~.TheoreticalPeak`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_method</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
            <span class="n">total_abundance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">experimental_distribution</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">theoretical_distribution</span><span class="p">:</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">*=</span> <span class="n">total_abundance</span>
            <span class="k">return</span> <span class="n">theoretical_distribution</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_method</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">peak</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">theoretical_distribution</span><span class="p">),</span>
                          <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">intensity</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">experimental_distribution</span><span class="p">[</span>
                <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">intensity</span> <span class="o">/</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">theoretical_distribution</span><span class="p">:</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">*=</span> <span class="n">scale_factor</span>
            <span class="k">return</span> <span class="n">theoretical_distribution</span>

    <span class="k">def</span> <span class="nf">subtraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isotopic_cluster</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract signal attributed to `isotopic_cluster` from the equivalent</span>
<span class="sd">        peaks in :attr:`peaklist`, mutating the peaks within.</span>

<span class="sd">        This will change the intensity value of the matched `FittedPeak` instances,</span>
<span class="sd">        and this is reflected in all of there references.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        isotopic_cluster : list of :class:`~.TheoreticalPeak`</span>
<span class="sd">            The isotopic cluster to subtract</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            Parts-per-million mass accuracy error tolerance to permit when</span>
<span class="sd">            finding matches for `isotopic_cluster`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">isotopic_cluster</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">intensity</span>
                <span class="n">match</span><span class="o">.</span><span class="n">intensity</span> <span class="o">-=</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">existing</span> <span class="o">*</span> <span class="mf">0.7</span><span class="p">)):</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">intensity</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">def</span> <span class="nf">_merge_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak_list</span><span class="p">):</span>
        <span class="n">peak_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">peak_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;neutral_mass&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">peak_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">current_peak</span> <span class="o">=</span> <span class="n">peak_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">merged_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peak_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">current_peak</span><span class="o">.</span><span class="n">neutral_mass</span> <span class="o">==</span> <span class="n">peak</span><span class="o">.</span><span class="n">neutral_mass</span> <span class="ow">and</span> <span class="n">current_peak</span><span class="o">.</span><span class="n">charge</span> <span class="o">==</span> <span class="n">peak</span><span class="o">.</span><span class="n">charge</span><span class="p">:</span>
                <span class="n">current_peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">+=</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_peak</span><span class="p">)</span>
                <span class="n">current_peak</span> <span class="o">=</span> <span class="n">peak</span>
        <span class="n">merged_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_peak</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_peaks</span>

    <span class="k">def</span> <span class="nf">_find_next_putative_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalibrates the current peak location given the position of the **next** putative peak</span>
<span class="sd">        in a theoretical isotopic cluster.</span>

<span class="sd">        Suppose that the peak at `mz` is roughly in the neighborhood of a real isotopic peak,</span>
<span class="sd">        but the alignment is bad, so it won&#39;t make a good starting point for the search for the</span>
<span class="sd">        rest of the peaks in its cluster under a stringent error tolerance.</span>

<span class="sd">        However, if we&#39;re willing to search for the **next** putative peak with a more permissive error</span>
<span class="sd">        tolerance, which we expect will be properly aligned with the rest of its isotopic cluster,</span>
<span class="sd">        we can recalibrate the proper starting peak&#39;s mz and use that for isotopic cluster fitting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mz : float</span>
<span class="sd">            Starting m/z value to search from</span>
<span class="sd">        charge : int</span>
<span class="sd">            Charge state to use when calculating the step size in m/z</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            The number of steps into the putative isotopic cluster to take. Defaults to 1</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The error tolerance to accept for finding supporting peaks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">isotopic_shift</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span>
        <span class="n">next_peak</span> <span class="o">=</span> <span class="n">mz</span> <span class="o">+</span> <span class="p">(</span><span class="n">shift</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">peaklist_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">between</span><span class="p">(</span>
            <span class="n">next_peak</span> <span class="o">-</span> <span class="p">(</span><span class="n">next_peak</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">),</span>
            <span class="n">next_peak</span> <span class="o">+</span> <span class="p">(</span><span class="n">next_peak</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">))</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">forward</span> <span class="ow">in</span> <span class="n">peaklist_slice</span><span class="p">:</span>
            <span class="n">prev_peak_mz</span> <span class="o">=</span> <span class="n">forward</span><span class="o">.</span><span class="n">mz</span> <span class="o">-</span> <span class="p">(</span><span class="n">shift</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">dummy_peak</span> <span class="o">=</span> <span class="n">FittedPeak</span><span class="p">(</span><span class="n">prev_peak_mz</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dummy_peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">candidates</span>

    <span class="k">def</span> <span class="nf">_find_previous_putative_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalibrates the current peak location given the position of the **previous** putative peak</span>
<span class="sd">        in a theoretical isotopic cluster.</span>

<span class="sd">        Suppose that the peak at `mz` is roughly in the neighborhood of a real isotopic peak,</span>
<span class="sd">        but the alignment is bad, so it won&#39;t make a good starting point for the search for the</span>
<span class="sd">        rest of the peaks in its cluster under a stringent error tolerance.</span>

<span class="sd">        However, if we&#39;re willing to search for the **previous** putative peak with a more permissive error</span>
<span class="sd">        tolerance, which we expect will be properly aligned with the rest of its isotopic cluster,</span>
<span class="sd">        we can recalibrate the proper starting peak&#39;s mz and use that for isotopic cluster fitting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mz : float</span>
<span class="sd">            Starting m/z value to search from</span>
<span class="sd">        charge : int</span>
<span class="sd">            Charge state to use when calculating the step size in m/z</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            The number of steps into the putative isotopic cluster to take. Defaults to 1</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The error tolerance to accept for finding supporting peaks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">isotopic_shift</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span>
        <span class="n">prev_peak</span> <span class="o">=</span> <span class="n">mz</span> <span class="o">-</span> <span class="p">(</span><span class="n">shift</span><span class="p">)</span>
        <span class="n">peaklist_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">between</span><span class="p">(</span>
            <span class="n">prev_peak</span> <span class="o">-</span> <span class="p">(</span><span class="n">prev_peak</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">),</span>
            <span class="n">prev_peak</span> <span class="o">+</span> <span class="p">(</span><span class="n">prev_peak</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">))</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">backward</span> <span class="ow">in</span> <span class="n">peaklist_slice</span><span class="p">:</span>
            <span class="n">prev_peak_mz</span> <span class="o">=</span> <span class="n">backward</span><span class="o">.</span><span class="n">mz</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_next_putative_peak</span><span class="p">(</span>
                    <span class="n">prev_peak_mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_find_previous_putative_peak</span><span class="p">(</span><span class="n">prev_peak_mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">candidates</span>

    <span class="k">def</span> <span class="nf">_check_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(peaklist=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">type_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AveragineDeconvoluterBase</span><span class="p">(</span><span class="n">DeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A base class derived from :class:`DeconvoluterBase` which provides some common methods</span>
<span class="sd">    for fitting isotopic patterns using an Averagine model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">minimum_intensity</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AveragineDeconvoluterBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_subtraction</span><span class="p">,</span> <span class="n">scale_method</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="p">,</span>
            <span class="n">minimum_intensity</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit_theoretical_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                                     <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit an isotopic pattern seeded at `peak` at `charge` charge.</span>

<span class="sd">        Generates a theoretical isotopic pattern using :attr:`averagine`, calls</span>
<span class="sd">        :meth:`match_theoretical_isotopic_distribution`</span>
<span class="sd">        to extract experimental peaks matching this theoretical pattern, scales the theoretical distribution using</span>
<span class="sd">        :meth:`scale_theoretical_distribution`, and evaluates the quality of the fit using :attr:`scorer`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The putative monoisotopic peak to use for interpolating an isotopic pattern</span>
<span class="sd">        error_tolerance : float</span>
<span class="sd">            Parts-per-million error tolerance for isotopic pattern matching</span>
<span class="sd">        charge : int</span>
<span class="sd">            The charge state to produce an isotopic pattern for</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The charge carrier mass, defaults to |PROTON|</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.IsotopicFitRecord`</span>
<span class="sd">            The fitted isotopic pattern</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">averagine</span><span class="o">.</span><span class="n">isotopic_cluster</span><span class="p">(</span>
            <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
            <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="n">eid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_theoretical_isotopic_distribution</span><span class="p">(</span>
            <span class="n">tid</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_theoretical_distribution</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">tid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IsotopicFitRecord</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_peaks_at_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak_charge_set</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                              <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a set of candidate monoisotopic peaks and charge states, and a PPM error tolerance,</span>
<span class="sd">        fit each putative isotopic pattern.</span>

<span class="sd">        Calls :meth:`fit_theoretical_distribution` on each candidate.</span>

<span class="sd">        If a fit does not satisfy :attr:`scorer` `.reject`, it is discarded. If a fit has only one real peak</span>
<span class="sd">        and has a charge state greater than 1, it will also be discarded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak_charge_set : set</span>
<span class="sd">            The set of candidate (:class:`~.FittedPeak`, charge) tuples to try to fit</span>
<span class="sd">        error_tolerance : float</span>
<span class="sd">            Matching error tolerance</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The charge carrier to use. Defaults to |PROTON|</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            The set of :class:`~.IsotopicFitRecord` instances produced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">peak_charge_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_theoretical_distribution</span><span class="p">(</span>
                <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="p">,</span>
                <span class="n">ignore_below</span><span class="p">)</span>
            <span class="n">fit</span><span class="o">.</span><span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">count_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fit</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ms_deisotope._c.deconvoluter_base</span> <span class="k">import</span> <span class="n">DeconvoluterBase</span><span class="p">,</span> <span class="n">AveragineDeconvoluterBase</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">charge_range_</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">abs_lo</span><span class="p">,</span> <span class="n">abs_hi</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lo</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">abs_lo</span><span class="p">,</span> <span class="n">abs_hi</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">abs_lo</span><span class="p">,</span> <span class="n">abs_hi</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">lower</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">c</span> <span class="o">*</span> <span class="n">sign</span>


<div class="viewcode-block" id="ExhaustivePeakSearchDeconvoluterBase"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.ExhaustivePeakSearchDeconvoluterBase">[docs]</a><span class="k">class</span> <span class="nc">ExhaustivePeakSearchDeconvoluterBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides common methods for algorithms which attempt to find a deconvolution for every peak</span>
<span class="sd">    in a spectrum. This assumes no dependence between different peaks, instead it relies on subtraction,</span>
<span class="sd">    breadth of search, and order of encounter to avoid artefactual fits. This is usually not reasonable,</span>
<span class="sd">    so instead please use this class&#39;s extension, :class:`PeakDependenceGraphDeconvoluterBase` which can</span>
<span class="sd">    express dependence of fits on common resources.</span>

<span class="sd">    This class is not meant to be instantiated, but instead used as a mixin for classes that also</span>
<span class="sd">    inherit from :class:`DeconvoluterBase` and provide methods `fit_theoretical_distribution`</span>
<span class="sd">    and `_fit_peaks_at_charges`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_all_peak_charge_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                                   <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                   <span class="n">recalculate_starting_peak</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the set of all unique candidate (monoisotopic peak, charge state) pairs using</span>
<span class="sd">        the provided search parameters.</span>

<span class="sd">        The search is performed using :func:`has_previous_peak_at_charge`, :func:`has_successor_peak_at_charge`,</span>
<span class="sd">        :meth:`_find_previous_putative_peak`, and :meth:`_find_next_putative_peak`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        recalculate_starting_peak : bool, optional</span>
<span class="sd">            Whether or not to re-calculate the putative starting peak m/z based upon nearby</span>
<span class="sd">            peaks close to where isotopic peaks for `peak` should be. Defaults to True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            The set of all unique candidate (monoisotopic peak, charge state)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_peaks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="s2">&quot;Considering charge range </span><span class="si">%r</span><span class="s2"> for </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                 <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">charge_range_</span><span class="p">(</span><span class="o">*</span><span class="n">charge_range</span><span class="p">)),</span> <span class="n">peak</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">charge_range_</span><span class="p">(</span><span class="o">*</span><span class="n">charge_range</span><span class="p">):</span>
            <span class="n">target_peaks</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">))</span>

            <span class="c1"># Look Left</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">left_search_limit</span><span class="p">):</span>
                <span class="n">prev_peak</span> <span class="o">=</span> <span class="n">has_previous_peak_at_charge</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prev_peak</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">target_peaks</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">prev_peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">recalculate_starting_peak</span><span class="p">:</span>
                    <span class="n">target_peaks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_previous_putative_peak</span><span class="p">(</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">error_tolerance</span><span class="p">))</span>

            <span class="c1"># Look Right</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="p">):</span>
                <span class="n">nxt_peak</span> <span class="o">=</span> <span class="n">has_successor_peak_at_charge</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nxt_peak</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">target_peaks</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nxt_peak</span><span class="p">,</span> <span class="n">charge</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">recalculate_starting_peak</span><span class="p">:</span>
                    <span class="n">target_peaks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_next_putative_peak</span><span class="p">(</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">error_tolerance</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">recalculate_starting_peak</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
                    <span class="n">target_peaks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_next_putative_peak</span><span class="p">(</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">error_tolerance</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">target_peaks</span>

    <span class="k">def</span> <span class="nf">_fit_all_charge_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                               <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">recalculate_starting_peak</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                               <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Carry out the fitting process for `peak`.</span>

<span class="sd">        This method calls :meth:`_get_all_peak_charge_pairs` to collect all hypothetical solutions</span>
<span class="sd">        for `peak`, and invokes :meth:`_fit_peaks_at_charges` to evaluate them.</span>

<span class="sd">        The method :meth:`_fit_peaks_at_charges` is required by this interface, but is not defined by</span>
<span class="sd">        it, as it depends upon the underlying isotopic pattern fitting algorithm. See one of the</span>
<span class="sd">        Averagine-based algorithms for an implementation, such as :class:`AveragineDeconvoluterBase`,</span>
<span class="sd">        a complementary ancestor with this class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        recalculate_starting_peak : bool, optional</span>
<span class="sd">            Whether or not to re-calculate the putative starting peak m/z based upon nearby</span>
<span class="sd">            peaks close to where isotopic peaks for `peak` should be. Defaults to True</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            The set of :class:`~.IsotopicFitRecord` instances produced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_all_peak_charge_pairs</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span>
            <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
            <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
            <span class="n">recalculate_starting_peak</span><span class="o">=</span><span class="n">recalculate_starting_peak</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_peaks_at_charges</span><span class="p">(</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span>
            <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">results</span><span class="p">)</span>

<div class="viewcode-block" id="ExhaustivePeakSearchDeconvoluterBase.charge_state_determination"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.ExhaustivePeakSearchDeconvoluterBase.charge_state_determination">[docs]</a>    <span class="k">def</span> <span class="nf">charge_state_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                                   <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                   <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                                   <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the optimal isotopic fit for `peak`, extracting it&#39;s charge state and monoisotopic peak.</span>

<span class="sd">        This method invokes :meth:`_fit_all_charge_states`, and then uses :attr:`scorer`&#39;s `select` method to</span>
<span class="sd">        choose the optimal solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.IsotopicFitRecord`</span>
<span class="sd">            The best scoring isotopic fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_all_charge_states</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span>
            <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fits for </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">)[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]:</span>
                <span class="n">info</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_make_deconvoluted_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">):</span>
        <span class="n">score</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
        <span class="n">total_abundance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">)</span>
        <span class="n">monoisotopic_mass</span> <span class="o">=</span> <span class="n">neutral_mass</span><span class="p">(</span>
            <span class="n">tid</span><span class="o">.</span><span class="n">monoisotopic_mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
        <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">first_peak</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>

        <span class="n">dpeak</span> <span class="o">=</span> <span class="n">DeconvolutedPeak</span><span class="p">(</span>
            <span class="n">neutral_mass</span><span class="o">=</span><span class="n">monoisotopic_mass</span><span class="p">,</span> <span class="n">intensity</span><span class="o">=</span><span class="n">total_abundance</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span>
            <span class="n">signal_to_noise</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">signal_to_noise</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">reference_peak</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">full_width_at_half_max</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">full_width_at_half_max</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">),</span>
            <span class="n">a_to_a2_ratio</span><span class="o">=</span><span class="n">a_to_a2_ratio</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span>
            <span class="n">most_abundant_mass</span><span class="o">=</span><span class="n">neutral_mass</span><span class="p">(</span>
                <span class="n">most_abundant_mz</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span> <span class="n">charge</span><span class="p">),</span>
            <span class="n">average_mass</span><span class="o">=</span><span class="n">neutral_mass</span><span class="p">(</span><span class="n">average_mz</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span> <span class="n">charge</span><span class="p">),</span>
            <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
            <span class="n">envelope</span><span class="o">=</span><span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">intensity</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eid</span><span class="p">],</span>
            <span class="n">mz</span><span class="o">=</span><span class="n">tid</span><span class="o">.</span><span class="n">monoisotopic_mz</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span>
            <span class="n">area</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dpeak</span>

<div class="viewcode-block" id="ExhaustivePeakSearchDeconvoluterBase.deconvolute_peak"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.ExhaustivePeakSearchDeconvoluterBase.deconvolute_peak">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                         <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                         <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a deconvolution for `peak`, generating a new :class:`ms_deisotope.peak_set.DeconvolutedPeak` instance</span>
<span class="sd">        corresponding to the optimal solution.</span>

<span class="sd">        This new peak has an m/z matching the monoisotopic peak of the pattern containing `peak`, and its intensity</span>
<span class="sd">        is the sum of all the matched peaks in its isotopic pattern. Its charge, isotopic fit, and other qualities</span>
<span class="sd">        are derived from the :class:`ms_deisotope.scoring.IsotopicFitRecord` instance corresponding to its best</span>
<span class="sd">        solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier, or more specifically, the moiety which is added for</span>
<span class="sd">            each incremental change in charge state. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.DeconvolutedPeak`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_state_determination</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span>
            <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span>
            <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">theoretical</span>
        <span class="n">dpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_deconvoluted_peak</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dpeak</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subtraction</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpeak</span></div>

<div class="viewcode-block" id="ExhaustivePeakSearchDeconvoluterBase.targeted_deconvolution"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.ExhaustivePeakSearchDeconvoluterBase.targeted_deconvolution">[docs]</a>    <span class="k">def</span> <span class="nf">targeted_deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                               <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                               <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                               <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Express the intent that this peak&#39;s deconvolution solution will be retrieved at a later point in the process</span>
<span class="sd">        and that it should be deconvoluted, and return a handle to retrieve the results with.</span>

<span class="sd">        This algorithm&#39;s implementation is simple enough that this is equivalent to just performing the deconvolution</span>
<span class="sd">        now and storing the result in a :class:`~.TrivialTargetedDeconvolutionResult` instance.</span>

<span class="sd">        Otherwise identical to :meth:`deconvolute_peak`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.TrivialTargetedDeconvolutionResult`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_peak</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span>
            <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">TrivialTargetedDeconvolutionResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dpeak</span><span class="p">,</span> <span class="n">peak</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="ExhaustivePeakSearchDeconvoluterBase.deconvolute"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.ExhaustivePeakSearchDeconvoluterBase.deconvolute">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                    <span class="n">order_chooser</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">),</span>
                    <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                    <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Completely deconvolute the spectrum.</span>

<span class="sd">        Visit each peak in the order chosen by `order_chooser`, and call :meth:`deconvolute_peak`</span>
<span class="sd">        on it with the provided arguments. This assumes all overlaps in isotopic pattern are captured</span>
<span class="sd">        by the search limits. This is usually not the case. For an alternative see</span>
<span class="sd">        :class:`PeakDependenceGraphDeconvoluterBase`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        order_chooser : callable, optional:</span>
<span class="sd">            A callable used as a key function for sorting peaks into the order they will</span>
<span class="sd">            be visited during deconvolution. Defaults to :obj:`operator.attrgetter(&quot;index&quot;)`</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.DeconvolutedPeakSet`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">order_chooser</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_intensity</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_peak</span><span class="p">(</span>
                <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
                <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
                <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_isobaric_peaks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_peaks</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DeconvolutedPeakSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span></div></div>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ms_deisotope._c.deconvoluter_base</span> <span class="k">import</span> <span class="p">(</span>
        <span class="n">_get_all_peak_charge_pairs</span> <span class="k">as</span> <span class="n">_c_get_all_peak_charge_pairs</span><span class="p">)</span>
    <span class="n">ExhaustivePeakSearchDeconvoluterBase</span><span class="o">.</span><span class="n">_get_all_peak_charge_pairs</span> <span class="o">=</span> <span class="n">_c_get_all_peak_charge_pairs</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="AveragineDeconvoluter"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.AveragineDeconvoluter">[docs]</a><span class="k">class</span> <span class="nc">AveragineDeconvoluter</span><span class="p">(</span><span class="n">AveragineDeconvoluterBase</span><span class="p">,</span> <span class="n">ExhaustivePeakSearchDeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Deconvoluter which uses an :title-reference:`averagine` [1] model to generate theoretical</span>
<span class="sd">    isotopic patterns for each peak to consider. Combines :class:`AveragineDeconvoluterBase` and</span>
<span class="sd">    :class:`ExhaustivePeakSearchDeconvoluterBase` to create a working Deconvoluter type.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    averagine : :class:`~.AveragineCache`</span>
<span class="sd">        The averagine model and associated theoretical isotopic pattern cache to use</span>
<span class="sd">        to build theoretical isotopic patterns.</span>
<span class="sd">    peaklist : :class:`~.PeakSet`</span>
<span class="sd">        The collection of ms_peak_picker.FittedPeak instances and possible associated</span>
<span class="sd">        data to deconvolute.</span>
<span class="sd">    scorer : :class:`~.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        How much diagnostic information to provide</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Senko, M. W., Beu, S. C., &amp; McLafferty, F. W. (1995). Determination of monoisotopic masses and ion populations</span>
<span class="sd">        for large biomolecules from resolved isotopic distributions. Journal of the American Society for Mass</span>
<span class="sd">        Spectrometry, 6(4), 229–233. http://doi.org/10.1016/1044-0305(95)00017-8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="n">averagine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">penalized_msdeconv</span><span class="p">,</span>
                 <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">averagine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">averagine</span> <span class="o">=</span> <span class="n">AveragineCache</span><span class="p">(</span><span class="n">peptide</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">averagine</span><span class="p">,</span> <span class="n">AveragineCache</span><span class="p">):</span>
                <span class="n">averagine</span> <span class="o">=</span> <span class="n">AveragineCache</span><span class="p">(</span><span class="n">averagine</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span> <span class="o">=</span> <span class="n">prepare_peaklist</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averagine</span> <span class="o">=</span> <span class="n">averagine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="o">=</span> <span class="n">scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AveragineDeconvoluter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_subtraction</span><span class="p">,</span> <span class="n">scale_method</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;scale_method&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_method</span><span class="p">,</span>
            <span class="s2">&quot;use_subtraction&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">,</span>
            <span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="s2">&quot;scorer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="p">,</span>
            <span class="s2">&quot;averagine&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">averagine</span>
        <span class="p">}</span></div>


<span class="k">class</span> <span class="nc">MultiAveragineDeconvoluterBase</span><span class="p">(</span><span class="n">DeconvoluterBase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_fit_peaks_at_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak_charge_set</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                              <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peak</span><span class="p">,</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">peak_charge_set</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">averagine</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averagines</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_theoretical_distribution</span><span class="p">(</span>
                    <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">averagine</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                    <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
                <span class="n">fit</span><span class="o">.</span><span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">count_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>
                <span class="n">fit</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">averagine</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fit</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ms_deisotope._c.deconvoluter_base</span> <span class="k">import</span> <span class="n">MultiAveragineDeconvoluterBase</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MultiAveragineDeconvoluter</span><span class="p">(</span><span class="n">MultiAveragineDeconvoluterBase</span><span class="p">,</span> <span class="n">ExhaustivePeakSearchDeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Deconvoluter which uses multiple :title-reference:`averagine` [1] model to generate theoretical</span>
<span class="sd">    isotopic patterns for each peak to consider. Combines :class:`MultiAveragineDeconvoluterBase` and</span>
<span class="sd">    :class:`ExhaustivePeakSearchDeconvoluterBase` to create a working Deconvoluter type.</span>

<span class="sd">    This differs from :class:`AveragineDeconvoluter`, in that it will produce multiple isotopic fits for</span>
<span class="sd">    each (peak, charge) pair. This is advantageous when the isotopic patterns produced by different models</span>
<span class="sd">    are sufficiently different enough that they will favor different peak sets.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    averagine : list of :class:`~.ms_deisotope.averagine.AveragineCache`</span>
<span class="sd">        The averagine models and associated theoretical isotopic pattern caches to use</span>
<span class="sd">        to build theoretical isotopic patterns.</span>
<span class="sd">    peaklist : :class:`~.ms_peak_picker.PeakSet`</span>
<span class="sd">        The collection of ms_peak_picker.FittedPeak instances and possible associated</span>
<span class="sd">        data to deconvolute.</span>
<span class="sd">    scorer : :class:`~.ms_deisotope.scoring.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        How much diagnostic information to provide</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Senko, M. W., Beu, S. C., &amp; McLafferty, F. W. (1995). Determination of monoisotopic masses and ion populations</span>
<span class="sd">        for large biomolecules from resolved isotopic distributions. Journal of the American Society for Mass</span>
<span class="sd">        Spectrometry, 6(4), 229–233. http://doi.org/10.1016/1044-0305(95)00017-8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="n">averagines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">penalized_msdeconv</span><span class="p">,</span>
                 <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span>
                 <span class="n">merge_isobaric_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minimum_intensity</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span> <span class="o">=</span> <span class="n">prepare_peaklist</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="o">=</span> <span class="n">scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span> <span class="o">=</span> <span class="n">use_subtraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_method</span> <span class="o">=</span> <span class="n">scale_method</span>

        <span class="n">cache_backend</span> <span class="o">=</span> <span class="nb">dict</span>
        <span class="k">if</span> <span class="n">averagines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">averagines</span> <span class="o">=</span> <span class="p">[</span><span class="n">peptide</span><span class="p">,</span> <span class="n">glycopeptide</span><span class="p">,</span> <span class="n">glycan</span><span class="p">]</span>
        <span class="n">averagines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">AveragineCache</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">cache_backend</span><span class="p">())</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">avg</span><span class="p">,</span> <span class="n">AveragineCache</span><span class="p">)</span> <span class="k">else</span> <span class="n">avg</span>
            <span class="k">for</span> <span class="n">avg</span> <span class="ow">in</span> <span class="n">averagines</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averagines</span> <span class="o">=</span> <span class="n">averagines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">MultiAveragineDeconvoluter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">use_subtraction</span><span class="p">,</span> <span class="n">scale_method</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="p">,</span>
            <span class="n">minimum_intensity</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="PeakDependenceGraphDeconvoluterBase"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.PeakDependenceGraphDeconvoluterBase">[docs]</a><span class="k">class</span> <span class="nc">PeakDependenceGraphDeconvoluterBase</span><span class="p">(</span><span class="n">ExhaustivePeakSearchDeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extends the concept of :class:`ExhaustivePeakSearchDeconvoluterBase` to include a way to handle</span>
<span class="sd">    conflicting solutions which claim the same experimental peak.</span>

<span class="sd">    This lets the Deconvoluter assign a single peak only once, and to the &quot;best&quot; solution to use it. To</span>
<span class="sd">    do this, the Deconvoluter constructs a graph where peaks are nodes, and isotopic fits are hyperedges</span>
<span class="sd">    connecting multiple nodes. Rather than deconvoluting the spectrum step by step, assigning signal as</span>
<span class="sd">    it explores the spectrum, the Deconvoluter instead inserts each considered isotopic fit into the graph.</span>
<span class="sd">    After completely traversing the spectrum, the Deconvoluter solves the dependence graph attempting to</span>
<span class="sd">    maximize some criterion and produce a set of disjoint isotopic fits. These fits are then assigned signal</span>
<span class="sd">    and added to the deconvoluted spectrum as normal.</span>

<span class="sd">    The criterion used is currently a greedy maximization (or minimization) of each connected component of</span>
<span class="sd">    the peak dependence graph.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    max_missed_peaks : int</span>
<span class="sd">        The maximum number of missing peaks to tolerate in an isotopic fit</span>
<span class="sd">    peak_dependency_network : :class:`~.PeakDependenceGraph`</span>
<span class="sd">        The peak dependence graph onto which isotopic fit dependences on peaks</span>
<span class="sd">        are constructed and solved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_missed_peaks&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ExhaustivePeakSearchDeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span> <span class="o">=</span> <span class="n">PeakDependenceGraph</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">is_maximizing</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">max_missed_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_postprocessor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fit_postprocessor&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_priority_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_missed_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">max_missed_peaks</span>

    <span class="nd">@max_missed_peaks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_missed_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_explore_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                       <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a peak, explore the local neighborhood for candidate isotopic fits and add each</span>
<span class="sd">        fit above a threshold to the peak dependence graph.</span>

<span class="sd">        The threshold assumes that a single peak&#39;s neighborhood will contain many, many fits, but</span>
<span class="sd">        that only the top `n` scoring fits are worth considering. For now, `n` is fixed at 100 or</span>
<span class="sd">        the half number of fits returned, whichever is larger. This is to prevent the fit graph</span>
<span class="sd">        from growing out of control and wasting time storing impractical fits. Any fit added to</span>
<span class="sd">        the graph will have to pass :attr:`scorer.select` as well, so weak fits will never be added,</span>
<span class="sd">        regardless of how many fits are allowed to be inserted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 1</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 0</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of fits added to the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_all_charge_states</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>

        <span class="n">hold</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">hold</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">hold</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fits for </span><span class="si">%r</span><span class="s2"> (</span><span class="si">%f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">mz</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stop</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="s2">&quot;Candidate: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">add_fit_dependence</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">i</span>

<div class="viewcode-block" id="PeakDependenceGraphDeconvoluterBase.populate_graph"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.PeakDependenceGraphDeconvoluterBase.populate_graph">[docs]</a>    <span class="k">def</span> <span class="nf">populate_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                       <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Visit each experimental peak and execute :meth:`_explore_local` on it with the provided</span>
<span class="sd">        parameters, populating the peak dependence graph with all viable candidates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 1</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 0</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_priority_map</span> <span class="ow">or</span> <span class="n">peak</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_intensity</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_explore_local</span><span class="p">(</span>
                <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
                <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
                <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">postprocess_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                         <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_postprocessor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

<div class="viewcode-block" id="PeakDependenceGraphDeconvoluterBase.select_best_disjoint_subgraphs"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.PeakDependenceGraphDeconvoluterBase.select_best_disjoint_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">select_best_disjoint_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct connected envelope graphs from :attr:`peak_dependency_network` and</span>
<span class="sd">        extract the best disjoint isotopic pattern fits in each envelope graph. This in turn</span>
<span class="sd">        produces one or more :class:`DeconvolutedPeak` instances from each disjoint fit,</span>
<span class="sd">        which are processed and added to the results set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The error tolerance to use when performing subtraction, if subtraction is</span>
<span class="sd">            being performed.</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier as used for the deconvolution. Required to</span>
<span class="sd">            back-out the neutral mass of the deconvoluted result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disjoint_envelopes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">find_non_overlapping_intervals</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">disjoint_envelopes</span><span class="p">:</span>
            <span class="n">disjoint_best_fits</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">disjoint_best_fits</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">disjoint_best_fits</span><span class="p">:</span>
                <span class="n">score</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span>
                <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">dpeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_deconvoluted_peak</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">add_solution</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">dpeak</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dpeak</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">subtraction</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeakDependenceGraphDeconvoluterBase.targeted_deconvolution"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.PeakDependenceGraphDeconvoluterBase.targeted_deconvolution">[docs]</a>    <span class="k">def</span> <span class="nf">targeted_deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                               <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                               <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Express the intent that this peak&#39;s deconvolution solution will be retrieved at a later point in the process</span>
<span class="sd">        and that it should be deconvoluted, and return a handle to retrieve the results with.</span>

<span class="sd">        As the operation does not immediately result in a deconvoluted peak but just adds the resulting fits to</span>
<span class="sd">        :attr:`peak_dependency_network`, this method constructs an instance of</span>
<span class="sd">        :class:`~.NetworkedTargetedDeconvolutionResult` which holds all</span>
<span class="sd">        the required information for recovering the best fit containing `peak`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : :class:`~.FittedPeak`</span>
<span class="sd">            The peak to start the search from</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of `peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of `peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.NetworkedTargetedDeconvolutionResult`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_explore_local</span><span class="p">(</span>
            <span class="n">peak</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
            <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
            <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">NetworkedTargetedDeconvolutionResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peak</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_priority_map</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="PeakDependenceGraphDeconvoluterBase.deconvolute"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.PeakDependenceGraphDeconvoluterBase.deconvolute">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                    <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">MAX_ITERATION</span><span class="p">,</span>
                    <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span>
                    <span class="n">convergence</span><span class="o">=</span><span class="n">CONVERGENCE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Completely deconvolute the spectrum.</span>

<span class="sd">        For each iteration, clear :attr:`peak_depencency_network`, then invoke :meth:`populate_graph`</span>
<span class="sd">        followed by :meth:`select_best_disjoint_subgraphs` to populate the resulting</span>
<span class="sd">        :class:`~.DeconvolutedPeakSet`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            The parts-per-million error tolerance in m/z to search with. Defaults to |ERROR_TOLERANCE|</span>
<span class="sd">        charge_range : tuple, optional</span>
<span class="sd">            The range of charge states to consider. Defaults to (1, 8)</span>
<span class="sd">        order_chooser : callable, optional:</span>
<span class="sd">            A callable used as a key function for sorting peaks into the order they will</span>
<span class="sd">            be visited during deconvolution. Defaults to :obj:`operator.attrgetter(&quot;index&quot;)`</span>
<span class="sd">        left_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the left of :obj:`peak`. Defaults to 3</span>
<span class="sd">        right_search_limit : int, optional</span>
<span class="sd">            The number of steps to search to the right of :obj:`peak`. Defaults to 3</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>
<span class="sd">        ignore_below : float, optional</span>
<span class="sd">            The minimum relative abundance to consider a peak in a theoretical isotopic</span>
<span class="sd">            pattern</span>
<span class="sd">        convergence : float, optional</span>
<span class="sd">            The threshold of the below which after the `(sum(intensity_before) - sum(</span>
<span class="sd">            intensity_after)) / sum(intensity_after)`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.DeconvolutedPeakSet`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">begin_signal</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">populate_graph</span><span class="p">(</span>
                <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
                <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
                <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_fits</span><span class="p">(</span>
                <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
                <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select_best_disjoint_subgraphs</span><span class="p">(</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">end_signal</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">begin_signal</span> <span class="o">-</span> <span class="n">end_signal</span><span class="p">)</span> <span class="o">/</span> <span class="n">end_signal</span> <span class="o">&lt;</span> <span class="n">convergence</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">begin_signal</span> <span class="o">=</span> <span class="n">end_signal</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_isobaric_peaks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_peaks</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DeconvolutedPeakSet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">))</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="AveraginePeakDependenceGraphDeconvoluter"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.AveraginePeakDependenceGraphDeconvoluter">[docs]</a><span class="k">class</span> <span class="nc">AveraginePeakDependenceGraphDeconvoluter</span><span class="p">(</span><span class="n">AveragineDeconvoluter</span><span class="p">,</span> <span class="n">PeakDependenceGraphDeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Deconvoluter which uses an :title-reference:`averagine` [1] model to generate theoretical</span>
<span class="sd">    isotopic patterns for each peak to consider, using a peak dependence graph to solve complex mass</span>
<span class="sd">    spectra.</span>

<span class="sd">    Extends :class:`AveragineDeconvoluter` to include features from</span>
<span class="sd">    :class:`PeakDependenceGraphDeconvoluterBase` making it suitable for deconvoluting complex spectra where</span>
<span class="sd">    peak overlaps are common.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    peaklist : :class:`~.PeakSet`</span>
<span class="sd">        The centroided mass spectrum to deconvolute</span>
<span class="sd">    scorer : :class:`~.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    averagine : :class:`~.AveragineCache`</span>
<span class="sd">        The averagine model and associated theoretical isotopic pattern cache to use</span>
<span class="sd">        to build theoretical isotopic patterns.</span>
<span class="sd">    max_missed_peaks : int</span>
<span class="sd">        The maximum number of missing peaks to tolerate in an isotopic fit</span>
<span class="sd">    peak_dependency_network : :class:`~.PeakDependenceGraph`</span>
<span class="sd">        The peak dependence graph onto which isotopic fit dependences on peaks</span>
<span class="sd">        are constructed and solved.</span>
<span class="sd">    merge_isobaric_peaks : bool</span>
<span class="sd">        If multiple passes produce peaks with identical mass values,</span>
<span class="sd">        should those peaks be summed</span>
<span class="sd">    minimum_intensity : float</span>
<span class="sd">        Experimental peaks whose intensity is below this level will be ignored</span>
<span class="sd">        by peak querying methods</span>
<span class="sd">    scale_method : str</span>
<span class="sd">        The name of the method to use to scale theoretical isotopic pattern intensities</span>
<span class="sd">        to match the experimental isotopic pattern</span>
<span class="sd">    use_subtraction : bool</span>
<span class="sd">        Whether or not to apply a subtraction procedure to experimental peaks after they</span>
<span class="sd">        have been fitted. This is only necessary if the same signal may be examined multiple</span>
<span class="sd">        times as in a multi-pass method or when peak dependence is not considered</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Produce extra logging information</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Senko, M. W., Beu, S. C., &amp; McLafferty, F. W. (1995). Determination of monoisotopic masses and ion populations</span>
<span class="sd">        for large biomolecules from resolved isotopic distributions. Journal of the American Society for Mass</span>
<span class="sd">        Spectrometry, 6(4), 229–233. http://doi.org/10.1016/1044-0305(95)00017-8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">AveragineDeconvoluter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">PeakDependenceGraphDeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">MultiAveraginePeakDependenceGraphDeconvoluter</span><span class="p">(</span><span class="n">MultiAveragineDeconvoluter</span><span class="p">,</span> <span class="n">PeakDependenceGraphDeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extends :class:`MultiAveragineDeconvoluter` to include features from</span>
<span class="sd">    :class:`PeakDependenceGraphDeconvoluterBase` making it suitable for deconvoluting complex spectra where</span>
<span class="sd">    peak overlaps are common.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    peaklist : :class:`~.ms_peak_picker.PeakSet`</span>
<span class="sd">        The centroided mass spectrum to deconvolute</span>
<span class="sd">    scorer : :class:`~.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    averagine : list of :class:`~.ms_deisotope.averagine.AveragineCache`</span>
<span class="sd">        The averagine model and associated theoretical isotopic pattern cache to use</span>
<span class="sd">        to build theoretical isotopic patterns.</span>
<span class="sd">    max_missed_peaks : int</span>
<span class="sd">        The maximum number of missing peaks to tolerate in an isotopic fit</span>
<span class="sd">    peak_dependency_network : :class:`~.PeakDependenceGraph`</span>
<span class="sd">        The peak dependence graph onto which isotopic fit dependences on peaks</span>
<span class="sd">        are constructed and solved.</span>
<span class="sd">    merge_isobaric_peaks : bool</span>
<span class="sd">        If multiple passes produce peaks with identical mass values,</span>
<span class="sd">        should those peaks be summed</span>
<span class="sd">    minimum_intensity : float</span>
<span class="sd">        Experimental peaks whose intensity is below this level will be ignored</span>
<span class="sd">        by peak querying methods</span>
<span class="sd">    scale_method : str</span>
<span class="sd">        The name of the method to use to scale theoretical isotopic pattern intensities</span>
<span class="sd">        to match the experimental isotopic pattern</span>
<span class="sd">    use_subtraction : bool</span>
<span class="sd">        Whether or not to apply a subtraction procedure to experimental peaks after they</span>
<span class="sd">        have been fitted. This is only necessary if the same signal may be examined multiple</span>
<span class="sd">        times as in a multi-pass method or when peak dependence is not considered</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Produce extra logging information</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">MultiAveragineDeconvoluter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">PeakDependenceGraphDeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="CompositionListDeconvoluterBase"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListDeconvoluterBase">[docs]</a><span class="k">class</span> <span class="nc">CompositionListDeconvoluterBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A mixin class to provide common features for deconvoluters which process spectra</span>
<span class="sd">    using a list of targeted compositions.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    composition_list : list of :class:`~.Mapping`</span>
<span class="sd">        A series of objects which represent elemental compositions and support</span>
<span class="sd">        the :class:`~.Mapping` interface to access their individual elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">composition_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">composition_list</span><span class="p">)</span>

<div class="viewcode-block" id="CompositionListDeconvoluterBase.generate_theoretical_isotopic_cluster"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListDeconvoluterBase.generate_theoretical_isotopic_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">generate_theoretical_isotopic_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                                              <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                                              <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a theoretical isotopic pattern for ``composition``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        composition : :class:`~.Mapping`</span>
<span class="sd">            An object representing an elemental composition</span>
<span class="sd">        charge : int</span>
<span class="sd">            The charge state to generate the isotopic pattern for</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>
<span class="sd">        mass_shift : float, optional</span>
<span class="sd">            An arbitrary mass shift to apply to the generated theoretical isotopic pattern,</span>
<span class="sd">            moving all peaks forward by that mass charge ratio transformed mass.</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier, or more specifically, the moiety which is added for</span>
<span class="sd">            each incremental change in charge state. Defaults to |PROTON|</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.TheoreticalIsotopicPattern`</span>
<span class="sd">            The theoretical isotopic pattern generated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">isotopic_variants</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">)</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">TheoreticalIsotopicPattern</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">tid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mz</span><span class="p">)</span>
        <span class="n">tid</span><span class="o">.</span><span class="n">truncate_after</span><span class="p">(</span><span class="n">truncate_after</span><span class="p">)</span>
        <span class="n">tid</span><span class="o">.</span><span class="n">ignore_below</span><span class="p">(</span><span class="n">ignore_below</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mass_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tid</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">mass_shift</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">charge</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tid</span></div>

    <span class="k">def</span> <span class="nf">recalibrate_theoretical_mz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theoretical_distribution</span><span class="p">,</span> <span class="n">experimental_mz</span><span class="p">):</span>
        <span class="n">theoretical_distribution</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">experimental_mz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theoretical_distribution</span>

<div class="viewcode-block" id="CompositionListDeconvoluterBase.fit_composition_at_charge"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListDeconvoluterBase.fit_composition_at_charge">[docs]</a>    <span class="k">def</span> <span class="nf">fit_composition_at_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                                  <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce an isotopic fit for `composition` at `charge` against the experimental peak set.</span>

<span class="sd">        This method requires that the instance also possess a method named `match_theoretical_isotopic_distribution`</span>
<span class="sd">        such as the one implemented in :class:`DeconvoluterBase`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        composition : :class:`~.Mapping`</span>
<span class="sd">            An object representing an elemental composition</span>
<span class="sd">        charge : int</span>
<span class="sd">            The charge state to generate the isotopic pattern for</span>
<span class="sd">        error_tolerance : float</span>
<span class="sd">            The mass accuracy required to for peak matches</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>
<span class="sd">        mass_shift : float, optional</span>
<span class="sd">            An arbitrary mass shift to apply to the generated theoretical isotopic pattern,</span>
<span class="sd">            moving all peaks forward by that mass charge ratio transformed mass.</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier, or more specifically, the moiety which is added for</span>
<span class="sd">            each incremental change in charge state. Defaults to |PROTON|</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.IsotopicFitRecord`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_theoretical_isotopic_cluster</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span>
                                                         <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">,</span>
                                                         <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">)</span>
        <span class="n">monoisotopic_peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">tid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">monoisotopic_peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recalibrate_theoretical_mz</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">monoisotopic_peak</span><span class="o">.</span><span class="n">mz</span><span class="p">)</span>
        <span class="n">eid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_theoretical_isotopic_distribution</span><span class="p">(</span>
            <span class="n">tid</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>

        <span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">count_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missed_peaks</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scale_theoretical_distribution</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">tid</span><span class="o">.</span><span class="n">peaklist</span><span class="p">)</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">IsotopicFitRecord</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">missed_peaks</span>
        <span class="k">return</span> <span class="n">fit</span></div>

    <span class="k">def</span> <span class="nf">_make_deconvoluted_peak_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">):</span>
        <span class="n">eid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">experimental</span>
        <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">theoretical</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span>
        <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
        <span class="n">total_abundance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eid</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">monoisotopic_mass</span> <span class="o">=</span> <span class="n">neutral_mass</span><span class="p">(</span>
            <span class="n">tid</span><span class="o">.</span><span class="n">monoisotopic_mz</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
        <span class="n">monoisotopic_mz</span> <span class="o">=</span> <span class="n">tid</span><span class="o">.</span><span class="n">monoisotopic_mz</span>

        <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">first_peak</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">DeconvolutedPeakSolution</span><span class="p">(</span>
            <span class="n">composition</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span>
            <span class="n">monoisotopic_mass</span><span class="p">,</span> <span class="n">total_abundance</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
            <span class="n">signal_to_noise</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">signal_to_noise</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">reference_peak</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">full_width_at_half_max</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">full_width_at_half_max</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">),</span>
            <span class="n">a_to_a2_ratio</span><span class="o">=</span><span class="n">a_to_a2_ratio</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span>
            <span class="n">most_abundant_mass</span><span class="o">=</span><span class="n">neutral_mass</span><span class="p">(</span>
                <span class="n">most_abundant_mz</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span> <span class="n">charge</span><span class="p">),</span>
            <span class="n">average_mass</span><span class="o">=</span><span class="n">neutral_mass</span><span class="p">(</span><span class="n">average_mz</span><span class="p">(</span><span class="n">eid</span><span class="p">),</span> <span class="n">charge</span><span class="p">),</span>
            <span class="n">score</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
            <span class="n">envelope</span><span class="o">=</span><span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">mz</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">intensity</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rep_eid</span><span class="p">],</span>
            <span class="n">mz</span><span class="o">=</span><span class="n">monoisotopic_mz</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">peak</span>

<div class="viewcode-block" id="CompositionListDeconvoluterBase.deconvolute_composition"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListDeconvoluterBase.deconvolute_composition">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                                <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span>
                                <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For each charge state under consideration, fit the theoretical isotopic pattern for this composition,</span>
<span class="sd">        and if the fit is satisfactory, add it to the results set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        composition : :class:`~.Mapping`</span>
<span class="sd">            An object representing an elemental composition</span>
<span class="sd">        error_tolerance : float</span>
<span class="sd">            The mass accuracy required to for peak matches</span>
<span class="sd">        charge_range : tuple</span>
<span class="sd">            The charge state range to generate the isotopic patterns for</span>
<span class="sd">        truncate_after : float, optional</span>
<span class="sd">            The percent of intensity to ensure is included in a theoretical isotopic pattern</span>
<span class="sd">            starting from the monoisotopic peak. This will cause theoretical isotopic patterns</span>
<span class="sd">            to be truncated, excluding trailing peaks which do not contribute substantially to</span>
<span class="sd">            the overall shape of the isotopic pattern.</span>
<span class="sd">        mass_shift : float, optional</span>
<span class="sd">            An arbitrary mass shift to apply to the generated theoretical isotopic pattern,</span>
<span class="sd">            moving all peaks forward by that mass charge ratio transformed mass.</span>
<span class="sd">        charge_carrier : float, optional</span>
<span class="sd">            The mass of the charge carrier, or more specifically, the moiety which is added for</span>
<span class="sd">            each incremental change in charge state. Defaults to |PROTON|</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">charge_range_</span><span class="p">(</span><span class="o">*</span><span class="n">charge_range</span><span class="p">):</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_composition_at_charge</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span>
                                                 <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                                                 <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
                <span class="n">eid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">experimental</span>
                <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">theoretical</span>
                <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_deconvoluted_peak_solution</span><span class="p">(</span>
                    <span class="n">fit</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">subtraction</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CompositionListDeconvoluter"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListDeconvoluter">[docs]</a><span class="k">class</span> <span class="nc">CompositionListDeconvoluter</span><span class="p">(</span><span class="n">CompositionListDeconvoluterBase</span><span class="p">,</span> <span class="n">DeconvoluterBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    composition_list : list of :class:`~.Mapping`</span>
<span class="sd">        A series of objects which represent elemental compositions and support</span>
<span class="sd">        the :class:`~.Mapping` interface to access their individual elements.</span>
<span class="sd">    peaklist : :class:`~ms_peak_picker.PeakSet`</span>
<span class="sd">        The collection of :class:`~.ms_peak_picker.FittedPeak` instances and possible associated</span>
<span class="sd">        data to deconvolute.</span>
<span class="sd">    scorer : :class:`~.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    merge_isobaric_peaks : bool</span>
<span class="sd">        If multiple passes produce peaks with identical mass values,</span>
<span class="sd">        should those peaks be summed</span>
<span class="sd">    minimum_intensity : float</span>
<span class="sd">        Experimental peaks whose intensity is below this level will be ignored</span>
<span class="sd">        by peak querying methods</span>
<span class="sd">    scale_method : str</span>
<span class="sd">        The name of the method to use to scale theoretical isotopic pattern intensities</span>
<span class="sd">        to match the experimental isotopic pattern</span>
<span class="sd">    use_subtraction : bool</span>
<span class="sd">        Whether or not to apply a subtraction procedure to experimental peaks after they</span>
<span class="sd">        have been fitted. This is only necessary if the same signal may be examined multiple</span>
<span class="sd">        times as in a multi-pass method or when peak dependence is not considered</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Produce extra logging information</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">,</span> <span class="n">scorer</span><span class="p">,</span>
                 <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span> <span class="o">=</span> <span class="n">prepare_peaklist</span><span class="p">(</span><span class="n">peaklist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span> <span class="o">=</span> <span class="n">scorer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">CompositionListDeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">)</span>
        <span class="n">DeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">use_subtraction</span><span class="o">=</span><span class="n">use_subtraction</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="n">scale_method</span><span class="p">,</span> <span class="n">merge_isobaric_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span>
                    <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">composition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_composition</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span>
                                         <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                                         <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">,</span>
                                         <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DeconvolutedPeakSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span></div>


<div class="viewcode-block" id="CompositionListPeakDependenceGraphDeconvoluter"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListPeakDependenceGraphDeconvoluter">[docs]</a><span class="k">class</span> <span class="nc">CompositionListPeakDependenceGraphDeconvoluter</span><span class="p">(</span><span class="n">CompositionListDeconvoluter</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    composition_list : list of :class:`~.Mapping`</span>
<span class="sd">        A series of objects which represent elemental compositions and support</span>
<span class="sd">        the :class:`~.Mapping` interface to access their individual elements.</span>
<span class="sd">    peaklist : :class:`~ms_peak_picker.PeakSet`</span>
<span class="sd">        The collection of ms_peak_picker.FittedPeak instances and possible associated</span>
<span class="sd">        data to deconvolute.</span>
<span class="sd">    scorer : :class:`~.IsotopicFitterBase`</span>
<span class="sd">        The criterion for evaluating individual isotopic pattern fits</span>
<span class="sd">    max_missed_peaks : int</span>
<span class="sd">        The maximum number of missing peaks to tolerate in an isotopic fit</span>
<span class="sd">    peak_dependency_network : :class:`~PeakDependenceGraph`</span>
<span class="sd">        The peak dependence graph onto which isotopic fit dependences on peaks</span>
<span class="sd">        are constructed and solved.</span>
<span class="sd">    merge_isobaric_peaks : bool</span>
<span class="sd">        If multiple passes produce peaks with identical mass values,</span>
<span class="sd">        should those peaks be summed</span>
<span class="sd">    minimum_intensity : float</span>
<span class="sd">        Experimental peaks whose intensity is below this level will be ignored</span>
<span class="sd">        by peak querying methods</span>
<span class="sd">    scale_method : str</span>
<span class="sd">        The name of the method to use to scale theoretical isotopic pattern intensities</span>
<span class="sd">        to match the experimental isotopic pattern</span>
<span class="sd">    use_subtraction : bool</span>
<span class="sd">        Whether or not to apply a subtraction procedure to experimental peaks after they</span>
<span class="sd">        have been fitted. This is only necessary if the same signal may be examined multiple</span>
<span class="sd">        times as in a multi-pass method or when peak dependence is not considered</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Produce extra logging information</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">,</span> <span class="n">scorer</span><span class="p">,</span>
                 <span class="n">use_subtraction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_method</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_missed_peaks&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CompositionListPeakDependenceGraphDeconvoluter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">peaklist</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">,</span> <span class="n">scorer</span><span class="p">,</span> <span class="n">use_subtraction</span><span class="p">,</span> <span class="n">scale_method</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span> <span class="o">=</span> <span class="n">PeakDependenceGraph</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">is_maximizing</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">max_missed_peaks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_missed_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">max_missed_peaks</span>

    <span class="nd">@max_missed_peaks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">max_missed_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">max_missed_peaks</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_save_peak_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>

<div class="viewcode-block" id="CompositionListPeakDependenceGraphDeconvoluter.deconvolute_composition"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.CompositionListPeakDependenceGraphDeconvoluter.deconvolute_composition">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                                <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span>
                                <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">charge_range_</span><span class="p">(</span><span class="o">*</span><span class="n">charge_range</span><span class="p">):</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_composition_at_charge</span><span class="p">(</span>
                <span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">add_fit_dependence</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">populate_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                       <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">composition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_composition</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="p">,</span>
                                         <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                                         <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_best_disjoint_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">):</span>
        <span class="n">disjoint_envelopes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">find_non_overlapping_intervals</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">disjoint_envelopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">disjoint_best_fits</span><span class="p">():</span>
                <span class="n">eid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">experimental</span>
                <span class="n">tid</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">theoretical</span>
                <span class="n">composition</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">data</span>
                <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">eid</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_deconvoluted_peak_solution</span><span class="p">(</span>
                    <span class="n">fit</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_peak_solution</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">subtraction</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">iterations</span><span class="o">=</span><span class="n">MAX_ITERATION</span><span class="p">,</span>
                    <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span>
                    <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convergence</span><span class="o">=</span><span class="n">CONVERGENCE</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_subtraction</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">begin_signal</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">populate_graph</span><span class="p">(</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">,</span>
                                <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select_best_disjoint_subgraphs</span><span class="p">(</span><span class="n">error_tolerance</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slice_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">end_signal</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">intensity</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peaklist</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">begin_signal</span> <span class="o">-</span> <span class="n">end_signal</span><span class="p">)</span> <span class="o">/</span> <span class="n">end_signal</span> <span class="o">&lt;</span> <span class="n">convergence</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">begin_signal</span> <span class="o">=</span> <span class="n">end_signal</span>
        <span class="k">return</span> <span class="n">DeconvolutedPeakSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deconvoluted_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span></div>


<span class="n">_APDGD</span> <span class="o">=</span> <span class="n">AveraginePeakDependenceGraphDeconvoluter</span>


<span class="k">class</span> <span class="nc">HybridAveragineCompositionListPeakDependenceGraphDeconvoluter</span><span class="p">(</span><span class="n">_APDGD</span><span class="p">,</span> <span class="n">CompositionListDeconvoluterBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">AveraginePeakDependenceGraphDeconvoluter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaklist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">CompositionListDeconvoluterBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deconvolute_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                                <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span>
                                <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">charge</span> <span class="ow">in</span> <span class="n">charge_range_</span><span class="p">(</span><span class="o">*</span><span class="n">charge_range</span><span class="p">):</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_composition_at_charge</span><span class="p">(</span>
                <span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">,</span> <span class="n">ignore_below</span><span class="o">=</span><span class="n">ignore_below</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">rep_eid</span> <span class="o">=</span> <span class="n">drop_placeholders</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">experimental</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_eid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fit</span><span class="o">.</span><span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scorer</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">fit</span><span class="p">):</span>
                <span class="n">fit</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">charge</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">peak_dependency_network</span><span class="o">.</span><span class="n">add_fit_dependence</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">populate_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                       <span class="n">ignore_below</span><span class="o">=</span><span class="n">IGNORE_BELOW</span><span class="p">,</span> <span class="n">mass_shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">composition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute_composition</span><span class="p">(</span>
                <span class="n">composition</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
                <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
                <span class="n">mass_shift</span><span class="o">=</span><span class="n">mass_shift</span><span class="p">)</span>
        <span class="n">AveraginePeakDependenceGraphDeconvoluter</span><span class="o">.</span><span class="n">populate_graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">,</span>
            <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
            <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subtraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isotopic_cluster</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HybridAveragineCompositionListPeakDependenceGraphDeconvoluter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">subtraction</span><span class="p">(</span>
            <span class="n">isotopic_cluster</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>


<div class="viewcode-block" id="deconvolute_peaks"><a class="viewcode-back" href="../../deconvolution/deconvolution.html#ms_deisotope.deconvolution.deconvolute_peaks">[docs]</a><span class="k">def</span> <span class="nf">deconvolute_peaks</span><span class="p">(</span><span class="n">peaklist</span><span class="p">,</span> <span class="n">decon_config</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">charge_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">ERROR_TOLERANCE</span><span class="p">,</span>
                      <span class="n">priority_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">right_search_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                      <span class="n">left_search_limit_for_priorities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right_search_limit_for_priorities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose_priorities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">PROTON</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">TRUNCATE_AFTER</span><span class="p">,</span>
                      <span class="n">deconvoluter_type</span><span class="o">=</span><span class="n">AveraginePeakDependenceGraphDeconvoluter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deconvolute a centroided mass spectrum</span>

<span class="sd">    This function constructs a deconvoluter object using the ``deconvoluter_type`` argument</span>
<span class="sd">    and deconvolutes the input ``peaklist`` by calling its :meth:`deconvolute` method.</span>

<span class="sd">    If ``priority_list`` is not :const:`None`, it is expected to be an iterable of either</span>
<span class="sd">    tuples of (:class:`~.FittedPeak`, ``(min charge, max charge)``) pairs, or instances of</span>
<span class="sd">    :class:`~.PriorityTarget`. These will be passed to :meth:`targeted_deconvolution` of</span>
<span class="sd">    the deconvoluter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaklist : :class:`~.PeakSet` or list of Peak-like objects</span>
<span class="sd">        The centroided mass spectrum to deconvolute.</span>
<span class="sd">    decon_config : dict, optional</span>
<span class="sd">        Parameters to use to initialize the deconvoluter instance produced by</span>
<span class="sd">        ``deconvoluter_type``</span>
<span class="sd">    charge_range : tuple of integers, optional</span>
<span class="sd">        The range of charge states to consider.</span>
<span class="sd">    error_tolerance : float, optional</span>
<span class="sd">        PPM error tolerance to use to match experimental to theoretical peaks</span>
<span class="sd">    priority_list : list, optional</span>
<span class="sd">        The set of peaks to target for deconvolution to be able to enforce external</span>
<span class="sd">        constraints on, such as selected precursors for fragmentation.</span>
<span class="sd">    left_search_limit : int, optional</span>
<span class="sd">        The maximum number of neutron shifts to search to the left  (decrease) from</span>
<span class="sd">        each query peak</span>
<span class="sd">    right_search_limit : int, optional</span>
<span class="sd">        The maximum number of neutron shifts to search to the right (increase) from</span>
<span class="sd">        each query peak</span>
<span class="sd">    left_search_limit_for_priorities : int, optional</span>
<span class="sd">        The maximum number of neutron shifts to search to the left (decrease) from</span>
<span class="sd">        each query peak for priority targets</span>
<span class="sd">    right_search_limit_for_priorities : int, optional</span>
<span class="sd">        The maximum number of neutron shifts to search to the right (increase) from</span>
<span class="sd">        each query peak for priority targets</span>
<span class="sd">    verbose_priorities : bool, optional</span>
<span class="sd">        Whether to turn on verbose mode for priority targets</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Passed to the deconvoluter to enable verbose mode globally</span>
<span class="sd">    charge_carrier : float, optional</span>
<span class="sd">        The mass of the charge carrier. Defaults to |PROTON|</span>
<span class="sd">    truncate_after : float, optional</span>
<span class="sd">        The percentage of the isotopic pattern to include. Defaults to |TRUNCATE_AFTER|</span>
<span class="sd">    deconvoluter_type : type or callable, optional</span>
<span class="sd">        A callable returning a deconvoluter. Defaults to :class:`~.AveraginePeakDependenceGraphDeconvoluter`</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Additional keywords included in ``decon_config``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`~.DeconvolutionProcessResult`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">priority_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">priority_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">left_search_limit_for_priorities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_search_limit_for_priorities</span> <span class="o">=</span> <span class="n">left_search_limit</span>
    <span class="k">if</span> <span class="n">right_search_limit_for_priorities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">right_search_limit_for_priorities</span> <span class="o">=</span> <span class="n">right_search_limit</span>

    <span class="n">decon_config</span> <span class="o">=</span> <span class="n">decon_config</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">decon_config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">decon_config</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;use_subtraction&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">decon_config</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;scale_method&quot;</span><span class="p">,</span> <span class="n">SCALE_METHOD</span><span class="p">)</span>
    <span class="n">decon</span> <span class="o">=</span> <span class="n">deconvoluter_type</span><span class="p">(</span><span class="n">peaklist</span><span class="o">=</span><span class="n">peaklist</span><span class="p">,</span> <span class="o">**</span><span class="n">decon_config</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose_priorities</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">decon</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">priority_list_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">priority_list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">target_info</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">target_info</span><span class="o">.</span><span class="n">peak</span>
            <span class="n">hinted_charge_range</span> <span class="o">=</span> <span class="n">target_info</span><span class="o">.</span><span class="n">charge_range_hint</span><span class="p">(</span><span class="n">charge_range</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">hinted_charge_range</span> <span class="o">=</span> <span class="n">charge_range</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">FittedPeak</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">decon</span><span class="o">.</span><span class="n">peaklist</span><span class="o">.</span><span class="n">has_peak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="p">)</span>
        <span class="n">priority_result</span> <span class="o">=</span> <span class="n">decon</span><span class="o">.</span><span class="n">targeted_deconvolution</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span>
            <span class="n">charge_range</span><span class="o">=</span><span class="n">hinted_charge_range</span><span class="p">,</span>
            <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit_for_priorities</span><span class="p">,</span>
            <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit_for_priorities</span><span class="p">,</span>
            <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span>
            <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">)</span>
        <span class="n">priority_list_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">priority_result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose_priorities</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">decon</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">deconvoluted_peaks</span> <span class="o">=</span> <span class="n">decon</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span>
        <span class="n">error_tolerance</span><span class="o">=</span><span class="n">error_tolerance</span><span class="p">,</span> <span class="n">charge_range</span><span class="o">=</span><span class="n">charge_range</span><span class="p">,</span> <span class="n">left_search_limit</span><span class="o">=</span><span class="n">left_search_limit</span><span class="p">,</span>
        <span class="n">right_search_limit</span><span class="o">=</span><span class="n">right_search_limit</span><span class="p">,</span> <span class="n">charge_carrier</span><span class="o">=</span><span class="n">charge_carrier</span><span class="p">,</span> <span class="n">truncate_after</span><span class="o">=</span><span class="n">truncate_after</span><span class="p">)</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pr</span> <span class="ow">in</span> <span class="n">priority_list_results</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not extract a solution for </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pr</span><span class="o">.</span><span class="n">query_peak</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">priority_list_results</span> <span class="o">=</span> <span class="n">acc</span>

    <span class="k">return</span> <span class="n">DeconvolutionProcessResult</span><span class="p">(</span>
        <span class="n">decon</span><span class="p">,</span> <span class="n">deconvoluted_peaks</span><span class="p">,</span> <span class="n">priority_list_results</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Joshua Klein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.7.
    </div>
  </body>
</html>